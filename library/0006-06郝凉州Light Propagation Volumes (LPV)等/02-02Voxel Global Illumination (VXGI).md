## 简介

Voxel Global Illumination（VXGI）是一个两趟的、实时的全局光照算法，它以体积渲染作为算法核心，将场景通过体素离散化为树状结构并存储光照计算相关信息，并在渲染时通过体素圆锥追踪来计算光照。

## 1.基本思想
Voxel Global Illumination (VXGI) 是基于体素化的场景表示。几何图形本身以稀疏体素八叉树的形式存储。这种结构提供了一个类似于mimmap的场景表示，因此可以快速测试空间的遮挡。


### 1.1场景体素化并构建层级
Voxel Global Illumination (VXGI) 是基于体素化的场景表示。将场景划分为细小的网格单元，几何图形本身以稀疏体素八叉树的形式存储。这种结构提供了一个类似于mimmap的场景表示，可以快速测试空间的遮挡。
<div align=center>![图1.1](https://renderwiki.github.io/ImageResources/VXGI/VXGI1.1.png)</div>
### 1.2体素信息存储
体素中包含关于它们所代表的几何图形反射的光照的信息。因为Radiance在六个主要方向上反射，它以一种定向的形式存储。使用RSM等方法找到被直接光照照亮的体素，记录直接光照来源方向和法线方向的分布，将其注入到八叉树的最低级别，然后将其向上传播到层次结构中。除了光线与法线的分布，在每个体素中还存储了体素的可见性和漫反射颜色。
<div align=center>![图1.2](https://renderwiki.github.io/ImageResources/VXGI/VXGI1.2.png)</div>
### 1.3查找
理想情况下，追踪光线以获得来自特定方向的Radiance值。然而，这样做需要很多射线，所以这些射线束被近似成一个圆锥，沿着它们的平均方向跟踪，只返回一个值。准确地测试圆锥与八叉树的交点并非易事，所以这个操作近似于沿着圆锥轴对树的一系列查询。每次查找都读取对应的树的层级，其节点大小对应于给定点上圆锥的横截面。
<div align=center>![图1.3](https://renderwiki.github.io/ImageResources/VXGI/VXGI1.3.png)</div>

## 2.拓展
### 2.1漫反射
为了计算漫反射，需要跟踪多个圆锥。生成的圆锥的数量是性能和精度之间的折衷。追踪更多的圆锥可以提供更高质量的结果，但代价是花费更多的时间。假设余弦项在整个锥上是常数，因此这项可以从反射率方程积分中分解出来。这样做使得漫反射照明的计算就像计算圆锥轨迹返回值的加权和一样简单。
<div align=center>![图2.1](https://renderwiki.github.io/ImageResources/VXGI/VXGI2.1.png)</div>
###2.2代价
使用稀疏八叉树存储光照的一个主要问题是查找成本高。查找包含给定位置的叶节点对应于一系列内存查找，并与确定要遍历哪个子树的简单逻辑交织在一起。一次特定的内存读取可能需要几百个周期。GPU试图通过并行执行多组着色器线程来隐藏这种延迟。即使在任何给定时间只有一个组执行ALU操作，当它需要等待内存读取时，另一个组会代替它。在遍历分层数据结构时，大部分时间都花在等待从内存中提取下一个节点上。
###2.3优化
McLaren用一组级联的三维纹理替换了八叉树，很像级联的LPV。它们有相同的尺寸，但覆盖的区域越来越大。这样，读取数据只需要一个常规的纹理查找就可以完成——不需要任何相关的读取。存储在纹理中的数据与稀疏八叉树中的数据是相同的。它们包含六个方向的反照率、占用率和反射光线信息。因为级联的位置会随着摄像机的移动而改变，所以物体会不断进出高分辨率区域。由于内存的限制，不可能让这些体素化的版本一直驻留在内存中，所以在需要的时候可以根据需要对它们进行体素化。


参考文献：
Crassin, Cyril, GigaVoxels: A Voxel-Based Rendering Pipeline For Efficient Exploration Of Large And Detailed Scenes, PhD thesis, University of Grenoble, July 2011.
《real-time rendering4》