## 简介

下面介绍更加基于物理的体积渲染方法，为了渲染体积中的介质，我们需要用某种方法表示介质的属性，并渲染其与光线产生的交互（详细见01节）。

体积渲染通常需要渲染一个非均匀的参与介质，因此可以使用体素来表示介质的属性，然而也存在其他表示方法，后续介绍体积渲染方法时将根据不同表示方法分类进行介绍。

体积渲染主要有两种方式：一种是解析方法，另一种是数值积分方法，后者的基础为Ray-marching采样。

此外，体积渲染还需要正确地将渲染结果和场景中其他元素进行混合，包括不透明表面和透明表面，这需要特殊处理。

整体参考[1]。

## 1.介质的表示方法
### 均匀介质
对于均匀的介质，通常使用一个简单形状来表示需要进行体积渲染的区域，光栅化时便可以自然的得到需要进行渲染的像素列表。如果需要对全屏幕进行体积渲染，则可以使用全屏后处理。除了屏幕上的覆盖范围，还需要表示体积的深度，这就需要对每个范围确定视线向量与其正反面交点的深度$d_f$和$d_b$，并相应的计算在这个区域中的体积深度$d=max(0, min(z_s, d_b)-d_f)$（其中$z_s$为背后最近的不透明表面的线性深度），得到在每个区域中的体积深度d后便可以计算透射率$T_r$，并得到覆盖率$\alpha=1.0-T_r$，最后使用alpha混合将所有区域雾的散射光进行合成。求区域前后交点深度存在一个single-pass的方法：将深度$d_s$和$1-d_s$分别存在两个通道中，并设置硬件混合为保留最小值，通过渲染一遍区域的形状便可得到$d_f$与$1-d_b$。


存在一种基于后处理的方法，使用解析解来准确计算光的单次散射：在均匀并且介质相函数为均匀相函数的情况下，假设介质不变，可以得到精确的透射率，对路径上的散射光值进行积分（##1098）。这一方法随后得到扩展（##1722），考虑了散射系数$\sigma_s$的影响，**并且考虑了介质散射对Lambertian表面的漫反射辐射度和Phong表面的镜面反射辐射度造成的影响（这句需要看一下原文献）**。为了支持透射率和相函数，可以使用一种ALU密集的方法（##1364）。这些解析模型非常有效，但是它们不支持通过shadowmap来渲染在体积中物体遮挡带来的阴影，也不支持非均匀的介质。

一些技术专注于渲染单光源、被阴影遮挡的大范围散射。Yusov介绍了一种沿极线采样入射光的方法，极线是指在摄像机投影平面上投影为同一直线的一系列直线。为了检查极线上每个采样样本是否被遮挡形成阴影，需要从光源视角渲染一张深度贴图。该方法从摄像机开始进行ray-marching，并使用一个沿射线的min/max层级来跳过那些未被遮挡的地方，只在深度不连续形成体积阴影处进行ray-marching。除了在极线上采样阴影，也有另一种方法在相机空间根据光源视角的深度图生成一个阴影mesh，在mesh覆盖的区域根据前后表面所夹体积来计算散射光（##765）。这两种方法在渲染被不透明表面遮挡的单次散射方面很有效，但是他们不能处理半透明表面带来的体积阴影（例如参与性介质的自阴影）和透明物体的透明阴影（如粒子）。此外，这些方法假设介质是恒定不变的，也不能非均匀介质。这两种方法在游戏中非常适合，由于跳过了未被遮挡的地方，可以在高分辨率下快速渲染（##1958） 

### Splatting方法
Splatting方法可以处理更一般情况的非均匀介质，用于沿射线对介质进行采样。Crane等人使用splatting方法通过流体模拟的方式渲染烟雾、火焰和水，但是没有考虑光照（##303）。每个像素生成一条射线进行ray-marching。在烟雾和火的情况下，ray-marching收集射线上每段的颜色和遮挡信息。而在水的情况下，ray-marching用于寻找水的表面，一旦遇到表面则停止继续向前步进，并使用密度场的梯度作为表面法向量，为了使水的表面平滑，可以对密度值使用使用三线性插值。

这种方式可以通过使用蓝噪声进一步改进，其在像素之间的随机量更加均匀，并且在上采样与混合周围样本时在视觉上更加平滑。对半分辨率的framebuffer进行上采样也可以使用四个随机的样本进行混合，这会引入噪声，但由于其在全分辨率下，可以轻松的被TAA消除。



### 切片方法
对于大范围的大气散射效果，Dobashi等人（##359）使用了一系列垂直视线方向的切平面来对整个体积进行采样，这些切平面是从后向前渲染的。Mitchell（##1219）也使用相同的方式来渲染聚光灯的光束，用shadowmap为不透明物体投射出体积的阴影。这种切片的方法详细请见###14.3.1

### 体素化方法
Wronski提出了一种在裁剪空间中将散射radiance体素化为3d体积贴图的方法（##1917），裁剪空间的体素在世界空间内成平截锥体形，经常被称为froxel，该方法中对每个froxel的中心计算散射radiance。体素坐标x, y对应屏幕上的坐标，而坐标z对应深度，xy轴分辨率一般取屏幕分辨率的八分之一，而z轴则一般根据质量和性能选取，一般选取64层切片。体积贴图的RGB通道存储内散射radiance$L_{scat_{in}}$，alpha通道存储消散系数$\sigma_t$，根据这些信息，可以通过从近到远迭代计算得到最终的散射radiance，计算过程如下：

$V_f\left[x, y, z\right]=\left(L_{scat}'+T_r'L_{scat_{in}}d_s, T_{r_{slice}}T_r'\right)$

其中$L_{scat}'=V_f\left[x, y, z-1\right]_{rgb},T_r'=V_f\left[x, y, z-1\right]_\alpha$，$T_{r_{slice}}=e^{-\sigma_t d_s}$，$ds$为当前切片的深度。经过该过程之后每个froxel中alpha部分存储了从视点到froxel路径上的总体透射率，rgb部分存储的相当于散射radiance与总体透射率乘积的前缀和，整条路径上的散射radiance路径积分。

需要注意的是对于在每个froxel中的radiance（$L_{scat_{in}}$）只受前一个froxel透射率影响，每个froxel中的散射radiance在不同深度位置上是相同的，没有考虑当前切片中的消散。针对这个问题Hillaire提出了一个解析地将$L_{scat_{in}}$和恒定消散系数$\sigma_t$进行积分的方法：

$V_f\left[x, y, z\right]=\left(L_{scat}'+\frac{L_{scat_{in}}-L_{scat_{in}}T_{r_{slice}}}{\sigma_t}, T_{r_{slice}}T_r'\right)$

完成散射radiance和透射率的计算后，每个像素最终的出射radiance $L_o$为$L_o=T_rL_s+L_{scat}$，$L_s$为不透明表面出射的radiance。由于基于体素方法的分辨率较低结果比较粗糙，其在相机移动和高频光源或阴影的情况下表现较差。这种基于体素方法可以使用在时间域重用方法（##742）

## 2.体积渲染
(把上述第一节的Ray-marching和解析方法挪过来)

## 3.结果的合成
为了提高性能，体积的渲染通常不是在全分辨率下进行的，通常是半分辨率或四分之一分辨率。因此在渲染完成后，需要应用多遍双边高斯模糊和双边上采样，将低分辨率的结果上采样到全分辨率下再和场景进行合成。

以上将体积划分成多个元素分别渲染的方法，其的共同缺点在于其中体积元需要进行深度排序，它们在和透明表面共同绘制的时候排序会出现问题，需要进行特殊处理，例如将体积内散射和透射率计算结果进行体素化，这就是另一类基于体素的方法。

体积散射结果的合成产生的artifact可以通过改变混合方式避免，称为考虑体积（volume-aware）的混合，通过使用“Rasterizer Order Views”这一最新的GPU特性（用于次序无关的半透明绘制，OIT）实现。考虑体积的混合会在一个framebuffer中储存n个最近粒子的深度，在绘制粒子时使用这些深度来实现确定性的（deterministic）混合。

## 参考文献：

[1] Tomas Akenine-Mller, Eric Haines, and Naty Hoffman. 2018. Real-Time Rendering, Fourth Edition (4th. ed.). A. K. Peters, Ltd., USA.

原论文引用，后续补上