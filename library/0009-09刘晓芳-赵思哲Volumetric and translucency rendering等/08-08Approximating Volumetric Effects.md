## 简介

下面介绍模拟体积效果的方法，这些方法在视觉上接近真实的体积效果，但不一定是基于物理的，可以说是某种特效或者Trick。然而它们比体积渲染更容易实现，同时当今仍能够取得不错的效果，因此广泛存在于各类实时应用中。

根据实现方式，本节分为后处理方法和Splatting方法两类进行介绍。

整体参考[1]。

## 后处理方法
### 1. 大规模雾效
雾可以通过基于深度的特效来近似实现，一个最基本的方式是根据相机到场景的距离对场景颜色和雾颜色进行alpha混合，这一方法通常被叫做深度雾（depth fog）。这种效果对观众来说是一个视觉提示，它可以提高真实感和艺术感，可以帮助场景的观察者确定物体的位置。最后，这种方法可以服务于遮挡剔除，被雾完全遮挡的过远物体可以安全的跳过渲染。

一种表示雾程度的方式是定义一个表示透射率的量f，其范围为[0-1]，例如f=0.1时表示场景表面的10%是可见的。应用雾效后的结果c可以表示为

$c=fc_i+(1-f)c_f$

其中$c_i$为场景表面的颜色，$c_f$为雾的颜色。

这一透射率f可以通过多种方式计算：例如根据距离线性增加，或者根据距离指数增加（服从Beer-Lambert定律）。OpenGL和DirectX中的硬件雾效就是根据这种方式定义的。

另一种常见的雾效是高度雾，其渲染了一层高度和厚度可变的参与介质，对于每个像素，雾的密度和散射光量是关于光线在这层介质中前近距离的函数。对于指数衰减的参与介质，透射率f存在解析解（Wenzel ##1871），这一方法可以使介质层的边缘处的雾过渡更加平滑。

深度雾和高度雾可以进一步扩展。雾的颜色$c_f$可以是美术定义的单色、根据视线方向从cubemap中采样的颜色，或者是通过per-pixel计算相函数得到的复杂大气散射效果。深度雾和高度雾效果可以进行组合，最终透射率$f=f_df_h$，同时存在两种效果。

（基于深度的雾效同样可以用于渲染水下光线的吸收，后续补上）

### 2. Bloom
在屏幕空间上模拟光散射效果可以使用bloom方法（##539，##1741），对图像进行模糊并将其中一部分叠加回原图像，使得亮的物体可以向周围泄露出光。这种方法经常用于模拟镜头的脏污，但是在某些情况下也适合模拟短距离无遮挡的散射。

### 3. 体积光束
另一种在屏幕空间上渲染遥远光源投射出的体积光束的方法由Mitchell（##1225）和Rohleder与Jamrozik（##1507）等人提出。首先，向全黑的buffer上渲染一个亮的物体，这一物体位于远平面，通过深度测试来剔除被遮挡的像素。然后，对buffer应用一个径向模糊，使第一步得到的光向外发散。这一模糊过程可使用可分过滤，将单次$n^2$个样本的过滤转化为两次$n$个样本的过滤（##1681）。最后，将模糊后的buffer内容叠加回渲染结果中。该方法的十分有效，产生的视觉效果很明显并且计算量较小，其缺点在于只有屏幕上可见光源才能投射出光束。

## Splatting方法
实现体积效果的最简单方式是渲染透明的mesh和背景进行混合，这被称为*splatting*方法。例如通过多个面向摄像机的面片粒子来渲染一道光束，每个粒子带有贴图并且沿着光束的方向拉伸。

splatting方法的缺陷在于多个透明mesh需要更高的带宽，容易导致性能瓶颈，并且透明的面片有时候会露馅。

（关于考虑深度的混合，OIT，后续挪过来）

## 参考文献：

[1] Tomas Akenine-Mller, Eric Haines, and Naty Hoffman. 2018. Real-Time Rendering, Fourth Edition (4th. ed.). A. K. Peters, Ltd., USA.

原论文引用，后续补上